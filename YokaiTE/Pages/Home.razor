@page "/"
@using IndexedDB.Blazor
@using System.Diagnostics
@using System.IO.Compression
@using System.Text
@using System.Text.Json
@using TG.Blazor.IndexedDB
@using YokaiTE.Component
@using YokaiTE.Enums
@using YokaiTE.Utils
@using YokaiTE.Modals

@inject IndexedDBManager DbManager
@inject NavigationManager Navigation
@inject IFileExporter FileExporter
@inject IFileImporter FileImporter
@inject IJSRuntime JsRuntime
@inject IFileInfoProvider FileInfoProvider

<PageTitle>Home</PageTitle>

@if (showRenameModal && selectedDocument != null)
{
    <RenameDocumentModal Document="selectedDocument" OnClose="() => showRenameModal = false"/>
}
<CreateDocumentModal Visible="@showCreateModal" VisibleChanged="@(v => showCreateModal = v)" OnSave="SaveDocument"/>
<DocumentContextMenu Visible="@showContextMenu"
                     VisibleChanged="@(v => showContextMenu = v)"
                     OnRename="OnRename"
                     OnDelete="OnDelete"
                     OnExport="OnExport"
                     Top="@contextMenuTop"
                     Left="@contextMenuLeft"/>
<div id="drop-zone" class="top-drop-zone">
    <div class="top-bar">

        <nav class="nav-container">
            <div @onclick="NavigateHome" class="logo-img">
                <img src="svg/logo.svg" alt="New doc"/>
            </div>

            <SearchInput ValueChanged="OnSearchInput" Value="@SearchValue" Placeholder="Pesquisar..."/>

            <div style="width:106px"></div>
        </nav>
    </div>
    <div id="shadow" class="upload-shadow"></div>
    <div class="page">
        <div class="documents">
            <div class="top-container">
                <span class="page-label">Meus arquivos</span>
                <div class="order-container">
                    <DualSelect Options="OrderOptions"
                                Value="@SelectedField"
                                ValueChanged="@OnOrderFieldChanged"
                                Order="@SelectedOrder"
                                OrderChanged="@OnOrderDirectionChanged"/>

                    <SwitchToggle @bind-Value="isCardView" AriaLabel="Alternar entre lista e grade"/>

                </div>
            </div>

            @if (isCardView)
            {
                <div class="doc-list-container">
                    <div @onclick="ShowCreateModal" class="document-card">
                        <div class="card-preview-create">
                            <img src="svg/plus.svg" alt="New doc"/>
                        </div>
                        <div class="card-info">
                            <span class="new-doc-span">Novo documento</span>
                            <span></span>
                        </div>
                    </div>
                    @foreach (var doc in documents)
                    {
                        <DocumentCard Document="doc"
                                      SelectedField="SelectedField"
                                      FileInfoProvider="FileInfoProvider"
                                      OnClick="() => EditDocument(doc.Id)"
                                      OnContextMenu="e => ShowContextMenu(e, doc)" />
                    }
                </div>
            }
            else
            {
                <div class="doc-grid-container">
                    <button @onclick="ShowCreateModal" class="grid-new-doc-btn">
                        <img src="svg/newFile.svg" alt="New doc"/>

                        <span>Novo arquivo</span>
                    </button>
                    <div class="grid-label-container">
                        <span class="w-50">Nome</span>
                        <span class="w-25">Editado por ultimo há</span>
                        <div class="w-25 d-flex">
                        <span>
                            Criado há
                        </span>
                            <div style="width:16px; height:16px;"></div>
                        </div>
                    </div>

                    @foreach (var doc in documents)
                    {
                        <div @oncontextmenu:preventDefault="true"
                             @onclick="(e => EditDocument(doc.Id))"
                             @oncontextmenu="(e => ShowContextMenu(e, doc))"
                             class="document-grid-item">
                            <div class="grid-item-name">
                                <img src="svg/doc-icon.svg" alt="Icon"/>
                                <span class="doc-title-grid">@doc.Title</span>
                            </div>
                            <div class="grid-item-date">
                                @FileInfoProvider.GetTimeAgo(doc.LastModified)
                            </div>
                            <div class="grid-item-date">
                            <span>
                                @FileInfoProvider.GetTimeAgo(doc.CreatedAt)

                            </span>
                                <button @onclick="(e => ShowContextMenu(e, doc))">
                                    <img src="svg/verticalDots.svg" alt="Icon"/>
                                </button>

                            </div>
                        </div>
                    }
                </div>
            }

        </div>
    </div>
</div>

@code {
    private DotNetObjectReference<Home> dotNetRef;

    private string _orderBy = string.Empty;
    private bool isCardView = true;

    private string SearchValue = string.Empty;
    private System.Timers.Timer? _debounceTimer;

    private bool showCreateModal = false;

    private bool showContextMenu = false;
    private int contextMenuTop;
    private int contextMenuLeft;
    private Document? selectedDocument;

    private string SelectedField { get; set; } = "Data de abertura";
    private SortOrder SelectedOrder { get; set; } = SortOrder.Desc;

    private bool showRenameModal = false;

    [JSInvokable]
    public async Task ImportHaikuFromBase64(string base64, string filename)
    {
        try
        {
            await FileImporter.ImportHaikuDoc(base64, filename);

            await LoadDocuments();
        }
        catch (Exception ex)
        {
            Debug.WriteLine(ex.Message);
            // fail silently ou log
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JsRuntime.InvokeVoidAsync("haikuDrop.register", dotNetRef, "drop-zone");

            // Verifica se a PWA recebeu um ficheiro via launchQueue (guardado em localStorage pelo script)
            try
            {
                var importJson = await JsRuntime.InvokeAsync<string>("localStorage.getItem", "haikuImport");
                if (!string.IsNullOrEmpty(importJson))
                {
                    // remove o item para não processar novamente
                    await JsRuntime.InvokeVoidAsync("localStorage.removeItem", "haikuImport");

                    var payload = JsonSerializer.Deserialize<ImportPayload>(importJson);
                    if (payload?.Base64 != null)
                    {
                        // chama o mesmo método já existente para importar
                        await ImportHaikuFromBase64(payload.Base64, payload.FileName ?? "import.haiku");
                    }
                }
            }
            catch
            {
                // ignore falhas simples
            }
        }
    }

    private class ImportPayload
    {
        public string Base64 { get; set; }
        public string FileName { get; set; }
    }

    private void OnSearchInput(string value)
    {
        SearchValue = value;

        _debounceTimer?.Stop();
        _debounceTimer?.Dispose();

        _debounceTimer = new System.Timers.Timer(300);
        _debounceTimer.Elapsed += async (_, __) =>
        {
            _debounceTimer?.Stop();
            _debounceTimer?.Dispose();
            _debounceTimer = null;

            await InvokeAsync(async () => await LoadDocuments());
        };
        _debounceTimer.AutoReset = false;
        _debounceTimer.Start();
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadDocuments();
    }

    private async Task ShowOptions(MouseEventArgs e, int documentId)
    {
        await JsRuntime.InvokeVoidAsync("ShowOptionsDocument", e, documentId);
    }

    private void ShowContextMenu(MouseEventArgs e, Document doc)
    {
        selectedDocument = doc;
        contextMenuTop = (int)e.ClientY;
        contextMenuLeft = (int)e.ClientX;
        showContextMenu = true;
        StateHasChanged();
    }

    private void ShowCreateModal()
    {
        showCreateModal = true;
    }

    private async Task SaveDocument(Document doc)
    {
        doc.PreviewPngBase64 = PreviewRenderer.RenderPngBase64(doc);


        var record = new StoreRecord<Document> { Storename = "documents", Data = doc };
        await DbManager.AddRecord(record);

        documents = await DbManager.GetRecords<Document>("documents");

        var novoDoc = documents
            .OrderByDescending(d => d.LastModified)
            .FirstOrDefault(d => d.Title == doc.Title && d.LastModified == doc.LastModified);

        if (novoDoc != null)
            Navigation.NavigateTo($"/edit/{novoDoc.Id}");
    }

    private void EditDocument(long id)
    {
        Navigation.NavigateTo($"/edit/{id}");
    }

    List<Document> documents = new()
    {
    };

    private void SortDocuments()
    {
        Func<Document, object>? keySelector = SelectedField switch
        {
            "Data de abertura" => d => d.LastOpened,
            "Data de edição" => d => d.LastModified,
            "Data de criação" => d => d.CreatedAt,
            "Ordem alfabética" => d => d.Title,
            _ => d => d.LastModified
        };

        if (SelectedOrder == SortOrder.Asc)
            documents = documents.OrderBy(keySelector).ToList();
        else
            documents = documents.OrderByDescending(keySelector).ToList();

        StateHasChanged();
    }

    private async Task OnOrderFieldChanged(string? field)
    {
        SelectedField = field ?? "Data de edição";
        SortDocuments();
        await Task.CompletedTask;
    }

    private async Task OnOrderDirectionChanged(SortOrder order)
    {
        SelectedOrder = order;
        SortDocuments();
        await Task.CompletedTask;
    }

    private async Task LoadDocuments()
    {
        var loadedDoc = await DbManager.GetRecords<Document>("documents");

        if (!string.IsNullOrWhiteSpace(SearchValue))
        {
            documents = loadedDoc
                .Where(d => d.Title.Contains(SearchValue, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        else
        {
            documents = loadedDoc.ToList();
        }

        SortDocuments();
        StateHasChanged();
    }

    private async Task OnRename()
    {
        if (selectedDocument is null) return;
        showRenameModal = true;
        StateHasChanged();
    }

    private async Task OnDelete()
    {
        if (selectedDocument is null)
        {
            Debug.WriteLine("No selected doc");
            return;
        }

        await DbManager.DeleteRecord<long>("documents", selectedDocument.Id);
        await LoadDocuments();
    }

    private async Task OnExport()
    {
        if (selectedDocument is null)
        {
            Debug.WriteLine("No selected doc");
            return;
        }

        await FileExporter.ExportHaikuDoc(selectedDocument);
    }

    private void NavigateHome()
    {
        Navigation.NavigateTo("/");
    }

    private List<string> OrderOptions = new() { "Data de abertura", "Data de edição", "Data de criação", "Ordem alfabética" };

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JsRuntime.InvokeVoidAsync("haikuDrop.unregister", "drop-zone");
        }
        finally
        {
            dotNetRef?.Dispose();
        }
    }

}
