@page "/edit/{Id:long}"
@using System.Diagnostics
@using System.Text
@using System.Text.Json
@using TG.Blazor.IndexedDB
@using Document = YokaiTE.Document
@using YokaiTE.Component
@using YokaiTE.Interfaces
@using YokaiTE.Utils
@using YokaiTE.Utils.TextHandlers
@inject NavigationManager Navigation
@inject IJSRuntime Js
@inject IDocumentMetrics DocumentMetrics
@inject IDocumentService DocumentService
@inject BreakpointService BreakpointService

@implements IAsyncDisposable

<PageTitle>Editar Documento</PageTitle>

@if (_document == null)
{
    // TODO loader aqui
    //pm um loading aqui
    <MockEditToolbar BackHome="BackHome"/>
    <div class="edit-page">

        <div class="editor-wrap">
            <div class="zen-editor skeleton" style="background:#F2F2F2">
                <div class="skeleton-paragraph">
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                    <div class="skeleton-line w-100"></div>
                </div>
                
            </div>
            <canvas class="overlay" @ref="_overlayRef"></canvas>
        </div>
    </div>
}
else
{
    <EditToolbar SelectionState="@_docState"
                 OnFontColorChanged="OnFontColorChanged"
                 OnHighlightColorChanged="OnHighlightColorChanged"
                 OnFontSizeChanged="OnFontSizeChanged"
                 OnFontFamilyChanged="OnFontFamilyChanged"
                 OnTextAlignChanged="OnTextAlignChanged"
                 OnFormattingChanged="OnFormattingChanged"
                 Document="_document"
                 IsSaved="_isSaved"
                 BackHome="BackHome"
                 TitleChanged="SaveTitleEdit"
                 SelectedFont="@_selectedFont"
                 SelectedFontChanged="OnSelectedFont"
                 Mobile="_isMobile"
    />
    <div class="edit-page">

        <div class="editor-wrap">
            <div class="zen-editor"
                 contenteditable="true"
                 @oninput="OnContentChanged"
                 @ref="_editorDiv"
                 style="background:@(_document?.BackgroundColor ?? "#F2F2F2")">
            </div>
            <canvas class="overlay" @ref="_overlayRef"></canvas>
        </div>
    </div>
    <DocInfoFooter 
        WordCount="DocumentMetrics.WordCount(_document!)"
        CharCount="DocumentMetrics.CharCount(_document!)"
        ByteCount="DocumentMetrics.GetDocumentSizeInBytes(_document!)"/>
}

@code {

    [Parameter] public long Id { get; set; }
    private readonly SelectionState _docState = new();
    private ElementReference _overlayRef;
    private Document? _document;
    private ElementReference _editorDiv;
    private bool _conteudoSetado = false;
    private DotNetObjectReference<Edit>? _dotNetRef;
    private IJSObjectReference? _spellMod;
    private bool _isSaved = true;
    private bool _overlayReady;

    //TODO pass the selected font to another area
    private string _selectedFont = string.Empty;

    private bool _isMobile;


    [JSInvokable]
    public async Task UpdateSelectionFormatting()
    {
        var state = await Js.InvokeAsync<SelectionState>("selectionStateInterop.getFormatting");
        _docState.Bold = state.Bold;
        _docState.Italic = state.Italic;
        _docState.Underline = state.Underline;
        _docState.Strike = state.Strike;

        _docState.TextAlign = state.TextAlign;
        _docState.FontSize = state.FontSize; // Atualiza o tamanho detectado
        StateHasChanged();
    }

    private async Task SaveTitleEdit(string editTitle)
    {
        if (!string.IsNullOrWhiteSpace(editTitle) && _document != null)
        {
            _document.Title = editTitle;
            await Salvar();
        }

        StateHasChanged();
    }
    private bool _eventsRegistered;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_document == null)
        {
            return;
        }

        // registre os eventos assim que houver documento (uma única vez)
        if (!_eventsRegistered)
        {
            _dotNetRef ??= DotNetObjectReference.Create(this);
            await Js.InvokeVoidAsync("registerEditorShortcuts", _dotNetRef);
            await Js.InvokeVoidAsync("selectionStateInterop.registerSelectionEvents", _dotNetRef);
            _eventsRegistered = true;
        }

        if (!_conteudoSetado)
        {
            await Js.InvokeVoidAsync("setZenContent", _editorDiv, _document.Content ?? "");
            await Js.InvokeVoidAsync("setupZenEditorSpanWrapper", _editorDiv);

            _conteudoSetado = true;

            if (_spellMod is not null)
            {
                await _spellMod.InvokeVoidAsync("init", _editorDiv, _overlayRef);
                _overlayReady = true;
                await _spellMod.InvokeVoidAsync("check", _editorDiv, _overlayRef);
            }

            // opcional: sincroniza estado inicial da toolbar após montar o conteúdo
            await Task.Delay(50);
            await UpdateSelectionFormatting();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await BreakpointService.InitializeAsync();
        BreakpointService.OnChange += HandleBreakpointChange;
        _isMobile = BreakpointService.CurrentBreakpoint == "mobile";

        _document = await DocumentService.LoadAsync(Id);
        _conteudoSetado = false;
    }

    private void HandleBreakpointChange(string bp)
    {
        _isMobile = bp == "mobile";
        InvokeAsync(StateHasChanged);
    }

    private async Task Salvar()
    {
        _document!.Content = await Js.InvokeAsync<string>("getZenContent", _editorDiv);
        await DocumentService.SaveAsync(_document);
        _isSaved = true;
        await Js.InvokeVoidAsync("removeBeforeUnloadHandler");
        StateHasChanged();
    }

    private CancellationTokenSource? _debounceCts;

    private async Task OnContentChanged()
    {
        _isSaved = false;
        _document!.Content = await Js.InvokeAsync<string>("getZenContent", _editorDiv);

        if (_overlayReady && _spellMod is not null)
            await _spellMod.InvokeVoidAsync("check", _editorDiv, _overlayRef);

        await Js.InvokeVoidAsync("addBeforeUnloadHandler");

        _debounceCts?.Cancel();
        _debounceCts = new CancellationTokenSource();
        var token = _debounceCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(1000, token);
                if (!token.IsCancellationRequested)
                {
                    await InvokeAsync(Salvar);
                }
            }
            catch (TaskCanceledException)
            {
            }
        });
    }

    [JSInvokable]
    public async Task SalvarViaAtalho()
    {
        await Salvar();
    }

    [JSInvokable]
    private async Task ExportSaveHaiku()
    {
        await DocumentService.ExportAsync(_document!);
    }

    private void OnSelectedFont(string font)
    {
        _selectedFont = font; // keeps parent state in sync with toolbar
    }


    //TODO implement push pop stack route
    private async Task BackHome()
    {
        await Salvar();
        Navigation.NavigateTo("/");
    }

    //Change to textFormatting

    #region text formatting

    private async Task OnFontFamilyChanged(string font)
    {
        await Js.InvokeVoidAsync("selectionStateInterop.applyFontFamily", font);

        // Optional: refresh formatting like you do for size/align
        await Task.Delay(50);
        await UpdateSelectionFormatting();
    }

    private async Task OnFontColorChanged(string color)
    {
        await Js.InvokeVoidAsync("selectionStateInterop.applyFontColor", color);
    }

    private async Task OnHighlightColorChanged(string color)
    {
        await Js.InvokeVoidAsync("selectionStateInterop.applyHighlightColor", color);
    }

    private async Task OnFontSizeChanged(string size)
    {
        _docState.FontSize = size;
        await Js.InvokeVoidAsync("applyFontSize", size);

        // Aguarda o DOM atualizar e então verifica o estado
        await Task.Delay(50);
        await UpdateSelectionFormatting();
    }

    private async Task OnTextAlignChanged(string align)
    {
        await Js.InvokeVoidAsync("applyTextAlign", align);

        // Aguarda o DOM atualizar e então verifica o estado
        await Task.Delay(50);
        await UpdateSelectionFormatting();
    }

    private async Task OnFormattingChanged()
    {
        await UpdateSelectionFormatting();
    }

    #endregion

    public async ValueTask DisposeAsync()
    {
        try
        {
            await Js.InvokeVoidAsync("unregisterEditorShortcuts");
            await Js.InvokeVoidAsync("selectionStateInterop.unregisterSelectionEvents");

            // if (overlayReady && _spellMod is not null)
            //     await _spellMod.InvokeVoidAsync("dispose", editorDiv);
            // if (_spellMod is not null)
            //     await _spellMod.DisposeAsync();
        }
        finally
        {
            _dotNetRef?.Dispose();
            BreakpointService.OnChange -= HandleBreakpointChange;
        }
    }

}
