@page "/edit/{Id:long}"
@using TG.Blazor.IndexedDB
@using QuestPDF.Fluent;
@using QuestPDF.Infrastructure;
@using Document = YokaiTE.Document
@inject IndexedDBManager DbManager
@inject NavigationManager Navigation
@implements IAsyncDisposable
<PageTitle>Editar Documento</PageTitle>

@if (document == null)
{
    <p>Carregando...</p>
}
else
{
    <div class="top-menu">
        <button class="btn-top-menu">Salvar</button>
        <div class="export-container" @onclick="() => showExport = true" >
            <button class="btn-top-menu">Exportar</button>
            @if (showExport)
            {
                <div class="export-options">
                    <button @onclick="ExportPdf">Exportar para PDF</button>
                    <button @onclick="ExportMd">Exportar para MD</button>
                    <button @onclick="ExportYk">Exportar para YK</button>
                </div>
            }
        </div>
        <button>Salvar</button>
    </div>
    <div class="edit-page">
        <div style="position:relative">
            <input @bind-value="document.Title" @bind-value:event="oninput" placeholder="Título" class="zen-title"/>
            @if (!isSaved)
            {
                <span class="non-saved-icon">*</span>
            }
        </div>

        <div class="zen-editor"
             contenteditable="true"
             @oninput="OnContentChanged"
             @ref="editorDiv">
        </div>

        <button @onclick="Salvar">Salvar</button>
    </div>
}

@code {
    [Parameter] public long Id { get; set; }

    private Document document;
    private ElementReference editorDiv;

    private string ultimoContentCarregado = null;

    private bool conteudoSetado = false;

    private DotNetObjectReference<Edit> dotNetRef;

    bool isSaved = true;

    bool showExport = false;

    private async void ExportPdf()
    {
        if (document == null) return;
        await JS.InvokeVoidAsync("exportPdfJs", document.Title, document.Content ?? "");
    }

    private void ExportMd()
    {
        /* lógica de exportação MD */
    }

    private void ExportYk()
    {
        /* lógica de exportação YK */
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerCtrlS", dotNetRef);
            // await JS.InvokeVoidAsync("addBeforeUnloadHandler"); // so quando eu edito car

        }

        if (document != null && !conteudoSetado)
        {
            await JS.InvokeVoidAsync("setZenContent", editorDiv, document.Content ?? "");
            conteudoSetado = true;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        document = await DbManager.GetRecordById<long, Document>("documents", Id);
        conteudoSetado = false; // Garante que o conteúdo será setado ao renderizar
        document.LastOpened = DateTime.Now;
        var record = new StoreRecord<Document> { Storename = "documents", Data = document };
        await DbManager.UpdateRecord(record);
    }

    private async Task Salvar()
    {
        // Captura o conteúdo editado
        document.Content = await JS.InvokeAsync<string>("getZenContent", editorDiv);
        document.LastModified = DateTime.Now;
        var record = new StoreRecord<Document> { Storename = "documents", Data = document };
        await DbManager.UpdateRecord(record);
        isSaved = true;
        await JS.InvokeVoidAsync("removeBeforeUnloadHandler"); // Remove o aviso
        StateHasChanged();
        // Navigation.NavigateTo("/");
    }

    private CancellationTokenSource debounceCts;

    private async Task OnContentChanged()
    {
        isSaved = false;
        document.Content = await JS.InvokeAsync<string>("getZenContent", editorDiv);
        await JS.InvokeVoidAsync("addBeforeUnloadHandler");

        debounceCts?.Cancel();
        debounceCts = new CancellationTokenSource();
        var token = debounceCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(5000, token);
                if (!token.IsCancellationRequested)
                {
                    await InvokeAsync(Salvar);
                }
            }
            catch (TaskCanceledException)
            {
            }
        });
    }

    [JSInvokable]
    public async Task SalvarViaAtalho()
    {
        await Salvar();
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("unregisterCtrlS");
        dotNetRef?.Dispose();
    }

    [Inject] IJSRuntime JS { get; set; }
}