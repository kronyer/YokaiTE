@page "/edit/{Id:long}"
@using TG.Blazor.IndexedDB
@using QuestPDF.Fluent;
@using QuestPDF.Infrastructure;
@using Document = YokaiTE.Document
@using YokaiTE.Component
@inject IndexedDBManager DbManager
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>Editar Documento</PageTitle>

@if (document == null)
{
    <p>Carregando...</p>
}
else
{
    <EditToolbar IsBold="isBold"
                 IsItalic="isItalic"
                 IsUnderline="isUnderline"
                 IsStrikeThrough="isStrike"
                 CurrentTextAlign="@currentTextAlign"
                 OnFontColorChanged="OnFontColorChanged"
                 OnHighlightColorChanged="OnHighlightColorChanged"
                 OnFontSizeChanged="OnFontSizeChanged"
                 OnFontFamilyChanged="OnFontFamilyChanged"
                 OnTextAlignChanged="OnTextAlignChanged"
    Document="document"
    IsSaved="isSaved"
    BackHome="BackHome"
    TitleChanged="SaveTitleEdit"
    SelectedFont="selectedFont"
    SelectedFontChanged="OnSelectedFont"
    OnBold="ApplyBoldAsync"
    OnItalic="ApplyItalicAsync"
    OnUnderline="ApplyUnderline"
    OnStrikeThrough="ApplyStrikethrough"/>
    <div class="edit-page">

        <div class="editor-wrap">
            <div class="zen-editor"
                 contenteditable="true"
                 
                 @oninput="OnContentChanged"
                 @ref="editorDiv"
                 style="background:@(document?.BackgroundColor ?? "#F2F2F2")">
            </div>
            <canvas class="overlay" @ref="overlayRef"></canvas>
        </div>


        
    </div>
    <DocInfoFooter CharCount="charCount" WordCount="wordCount" ByteCount="savedDocSize" />
}

@code {
    private bool isBold, isItalic, isUnderline, isStrike;
    private string currentTextAlign = "left";

    private IJSObjectReference? _selMod;

    [Parameter] public long Id { get; set; }
    private ElementReference overlayRef;

    private int charCount => string.IsNullOrEmpty(document?.Content)
        ? 0
        : System.Net.WebUtility.HtmlDecode(
            System.Text.RegularExpressions.Regex.Replace(document.Content, "<.*?>", string.Empty)
          ).Length;
    private int wordCount => string.IsNullOrWhiteSpace(document?.Content)
    ? 0
    : System.Net.WebUtility.HtmlDecode(
        System.Text.RegularExpressions.Regex.Replace(document.Content, "<.*?>", string.Empty)
      ).Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
    private int savedDocSize = 0;
    private Document document;
    private ElementReference editorDiv;

    private string ultimoContentCarregado = null;

    private bool conteudoSetado = false;

    private DotNetObjectReference<Edit> dotNetRef;
    private IJSObjectReference? _spellMod;
    private bool isEditingTitle = false;
    bool isSaved = true;
    private bool overlayReady;
    // bool showExport = false;

    private string selectedFont = string.Empty;

    private async Task SaveTitleEdit(string editTitle)
    {
        if (!string.IsNullOrWhiteSpace(editTitle) && document != null)
        {
            document.Title = editTitle;
            await Salvar();
        }
        isEditingTitle = false;
        StateHasChanged();
    }

    private int GetDocumentSizeInBytes()
    {
        if (document == null)
            return 0;

        var json = System.Text.Json.JsonSerializer.Serialize(document);

        return System.Text.Encoding.UTF8.GetByteCount(json);
    }


    private async void ExportPdf()
    {
        if (document == null) return;
        await JS.InvokeVoidAsync("exportPdfJs", document.Title, document.Content ?? "");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("registerEditorShortcuts", dotNetRef);

            //pm check bold etc
            await JS.InvokeVoidAsync("selectionStateInterop.registerSelectionEvents", dotNetRef);


            //TODO this is important, but not now
            // _spellMod = await JS.InvokeAsync<IJSObjectReference>("import", "/js/spellOverlay.js");
        }

        if (document != null && !conteudoSetado)
        {
            await JS.InvokeVoidAsync("setZenContent", editorDiv, document.Content ?? "");
            conteudoSetado = true;

            if (_spellMod is not null)
            {
                await _spellMod.InvokeVoidAsync("init", editorDiv, overlayRef);
                overlayReady = true;

                // primeira pintura (opcional)
                await _spellMod.InvokeVoidAsync("check", editorDiv, overlayRef);
            }
        }
    }

    [JSInvokable]
    public async Task UpdateSelectionFormatting()
    {
        var state = await JS.InvokeAsync<SelectionState>("selectionStateInterop.getFormatting");
        isBold = state.Bold;
        isItalic = state.Italic;
        isUnderline = state.Underline;
        isStrike = state.Strike;
        currentTextAlign = state.TextAlign;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        document = await DbManager.GetRecordById<long, Document>("documents", Id);
        conteudoSetado = false; // Garante que o conteúdo será setado ao renderizar
        document.LastOpened = DateTime.Now;
        var record = new StoreRecord<Document> { Storename = "documents", Data = document };
        await DbManager.UpdateRecord(record);

        savedDocSize = GetDocumentSizeInBytes();

    }

    private async Task Salvar()
    {
        // Captura o conteúdo editado
        document.Content = await JS.InvokeAsync<string>("getZenContent", editorDiv);
        document.LastModified = DateTime.Now;
        var record = new StoreRecord<Document> { Storename = "documents", Data = document };
        await DbManager.UpdateRecord(record);
        isSaved = true;
        savedDocSize = GetDocumentSizeInBytes();
        await JS.InvokeVoidAsync("removeBeforeUnloadHandler"); // Remove o aviso
        StateHasChanged();
    }

    private CancellationTokenSource debounceCts;

    private async Task OnContentChanged()
    {
        isSaved = false;
        document.Content = await JS.InvokeAsync<string>("getZenContent", editorDiv);
        
        if (overlayReady && _spellMod is not null)
            await _spellMod.InvokeVoidAsync("check", editorDiv, overlayRef);

        await JS.InvokeVoidAsync("addBeforeUnloadHandler");

        debounceCts?.Cancel();
        debounceCts = new CancellationTokenSource();
        var token = debounceCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(1000, token);
                if (!token.IsCancellationRequested)
                {
                    await InvokeAsync(Salvar);
                }
            }
            catch (TaskCanceledException)
            {
            }
        });
    }

    [JSInvokable]
    public async Task SalvarViaAtalho()
    {
        await Salvar();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("unregisterEditorShortcuts");
            await JS.InvokeVoidAsync("selectionStateInterop.unregisterSelectionEvents"); 

            // if (overlayReady && _spellMod is not null)
            //     await _spellMod.InvokeVoidAsync("dispose", editorDiv);
            // if (_spellMod is not null)
            //     await _spellMod.DisposeAsync();
        }
        finally
        {
            dotNetRef?.Dispose();
        }
    }

    [Inject] IJSRuntime JS { get; set; }

    private void OnSelectedFont(string font)
    {
        selectedFont = font;
    }

    private async Task BackHome()
    {
        await Salvar();
        Navigation.NavigateTo("/");
    }
    private async Task ApplyBoldAsync()
    {
        await JS.InvokeVoidAsync("applyBold");
    }
    private async Task ApplyItalicAsync()
    {
        await JS.InvokeVoidAsync("applyItalic");
    }

    private async Task ApplyUnderline()
    {
        await JS.InvokeVoidAsync("applyUnderline");
    }

    private async Task ApplyStrikethrough()
    {
        await JS.InvokeVoidAsync("applyStrikethrough");
    }

    private async Task OnFontColorChanged(string color)
    {
        await JS.InvokeVoidAsync("selectionStateInterop.applyFontColor", color);
    }
    private async Task OnHighlightColorChanged(string color)
    {
        await JS.InvokeVoidAsync("selectionStateInterop.applyHighlightColor", color);
    }
    private async Task OnFontSizeChanged(string size)
    {
        await JS.InvokeVoidAsync("selectionStateInterop.applyFontSize", size);
    }
    private async Task OnFontFamilyChanged(string font)
    {
        await JS.InvokeVoidAsync("selectionStateInterop.applyFontFamily", font);
    }
    private async Task OnTextAlignChanged(string align)
    {
            await JS.InvokeVoidAsync("applyTextAlign", align);
    
            // Aguarda o DOM atualizar e então verifica o estado
            await Task.Delay(50);
            await UpdateSelectionFormatting();
    }

    public sealed class SelectionState
    {
        public bool Bold { get; set; }
        public bool Italic { get; set; }
        public bool Underline { get; set; }
        public bool Strike { get; set; }
        public bool IsMixed { get; set; }
        public string TextAlign { get; set; } = "left";
    }

}
